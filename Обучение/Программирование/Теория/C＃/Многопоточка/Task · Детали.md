Способы создания `Task`:

- с использованием конструктора и делегата `Action` или `Action<Object>`:

```csharp
new Task(ComputeBoundUp, 5).Start();
```

- с использованием статического метода `Run` и делегата `Action` или `Func<TResult>`, также можно передать структуру `CancellationToken`, чтобы можно было прервать выполнение задачи:

```csharp
Task.Run(() => ComputeBoundUp(5));
```

### Как завершить задание и получить результат

Для ожидания завершения задачи используется метод `Wait()`, который может принимать еще тайм-аут или структуру `CancellationToken`:

```csharp
Task<int> t = new Task<int>(n => Sum(int n, 1000000));

t.Start(); // запускаем задачу

t.Wait(); // ждем пока задача выполниться

Console.WriteLine($"The sum is {t.Result}");
```

>[!danger] Важно
>**Логика работы метода Wait:**
>
>- Когда поток вызывает метод Wait, система сначала проверяет, началось ли уже выполнение ожидаемой задачи
>- Если задача уже выполняется, то вызывающий поток блокируется до её завершения
>- Если задача ещё не начала выполняться, система может (в зависимости от TaskScheduler) выполнить её непосредственно в том же потоке, который вызвал Wait

**Преимущества оптимизации:**

- Экономия ресурсов - не нужно создавать дополнительные потоки
- Повышение производительности - отсутствуют затраты на создание потоков и переключение контекста

**Потенциальная проблема:** При использовании Wait может возникнуть **взаимная блокировка (deadlock)** в случаях, когда:

1. Поток заблокирован на синхронизации перед вызовом Wait
2. Задача, которую он пытается выполнить, требует доступа к тем же заблокированным ресурсам

В такой ситуации возникает тупиковая ситуация - поток не может разблокировать ресурсы, пока не выполнит задачу, а задача не может выполниться без доступа к заблокированным ресурсам.

### Обработка исключений в Task

- Исключения из Task оборачиваются в `AggregateException`

```csharp
try
{
    task.Wait();
}
catch (AggregateException ex)
{
    // Обработка исключений из задачи
    foreach (var innerExce ption in ex.InnerExceptions)
    {
        Console.WriteLine($"Исключение: {innerException.Message}");
    }
}
```

- Если задача выбросила несколько исключений, все они будут доступны через свойство `InnerExceptions`
- Метод `Wait()` блокирует текущий поток до завершения задачи, включая случаи, когда задача завершается с исключением

**Альтернативы для обработки исключений:**

- Проверка свойства `task.Exception` после завершения
- Использование `task.IsFaulted` для проверки наличия исключений
- Асинхронный подход с `await` и обычными `try-catch` блоками

### Task.Delay() vs Thread.Sleep()

| Характеристика                 | Task.Delay                                                                                                                                                   | Thread.Sleep                                                                                                                        |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| блокирует поток                | нет, поток возвращается в пул потоков                                                                                                                        | **да**, поток не может выполнять другую работу                                                                                      |
| синхронный                     | нет, возвращает Task, который можно ожидать                                                                                                                  | да                                                                                                                                  |
| расходует ресурсы              | нет, т.к. поток может обрабатывать другие задачи                                                                                                             | да, т.к. заблокированный поток остается в памяти                                                                                    |
| можно прервать работу досрочно | да, через CancellationToken                                                                                                                                  | нет                                                                                                                                 |
| когда использовать             | - В веб-приложениях (ASP.NET)<br>- В UI-приложениях (WinForms, WPF)<br>- Когда важна отзывчивость и масштабируемость<br>- При работе с async/await паттерном | - В консольных приложениях или фоновых задачах<br>- Когда нужна простая пауза без асинхронности<br>- В тестах для имитации задержек |
#### Масштабируемость

```csharp
// Плохо: блокирует 1000 потоков
for (int i = 0; i < 1000; i++)
{
    Task.Run(() => Thread.Sleep(5000));
}

// Хорошо: использует минимум потоков
for (int i = 0; i < 1000; i++)
{
    Task.Delay(5000);
}
```